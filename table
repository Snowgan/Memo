<template lang="pug">
  div.blotter-table(:style="{ height: 'calc(100% - ' + theaderH + 'px)', top: theaderH + 'px' }")
    <div class="loading" v-if="loading"></div>
    div.filter-wrapper(v-if="curFilterData.showCol !== ''" :style="{ left: curFilterData.left + 'px', height: curFilterData.dropList.length > 0 ? '100%' : 'auto' }")
      filter-box(:dropList="curFilterData.dropList"
                 :selectedList="curFilterData.selectedList"
                 :textCriteria="curFilterData.textCriteria"
                 :title="curFilterData.showCol !== '' ? columnMap[curFilterData.showCol].title : ''"
                 :rules="blotterConfig.textFilterRules"
                 :type="filterCriteria[curFilterData.showCol] ? filterCriteria[curFilterData.showCol].type : ''"
                 :left="curFilterData.left"
                 @close-box="toggleFilterBox(curFilterData.showCol)"
                 @do-filter="doFilter"
                 @clear-filter="clearFilter")
    div.fake-table(ref="fakeTB" :style="{ top: '-' + theaderH + 'px' }")
      table.table(:style="{ width: headerW + 'px' }")
        thead
          tr(ref="fakeHeader" :style="{ height: theaderH + 'px' }")
            th(v-for="(header, idx) in fakeHeaderArr"
               :class="{ draggable: columnMap[header].draggable }"
               :style="columnMap[header].colStyle('HEADER')"
               :data-id="idx"
               :data-header="header"
               @click.stop="headerClickHandler(header, $event)"
               v-resize-width="")
              span(v-if="columnMap[header].type === 'data'") {{ columnMap[header].title }}
              i.icon--funnel.filter-flag(v-if="columnMap[header].type === 'data' && filterCriteria[header]")
              i.sort-flag(:class="{ 'icon--tick-down': sortCriteria.type === 'desc', 'icon--tick-up': sortCriteria.type === 'asc' }" v-if="columnMap[header].type === 'data' && sortCriteria.colHeader === header")
              input(v-if="columnMap[header].type === 'checkbox'" type="checkbox")
              span.drag-zone(v-show="columnMap[header].draggable && showDragZone"
                             :style="{ height: tbBodyH + 'px' }")
    div.real-table(ref="realTB")
      div(:style="{ width: headerW + 'px', height: totalDataH + 'px' }")
        table.table(:style="{ 'margin-top': '-' + theaderH + 'px', top: tbOffsetY + 'px' }")
          thead
            tr(ref="realHeader" :style="{ height: theaderH + 'px' }")
              th(v-for="header in realHeaderArr"
                 :style="columnMap[header].colStyle('HEADER')")
                span(v-if="columnMap[header].type === 'data'") {{ columnMap[header].title }}
                input(v-if="columnMap[header].type === 'checkbox'" type="checkbox")
          tbody(ref="realBody")
            tr(v-for="(item, idx) in renderList" :style="{ height: rowH + 'px' }")
              td(v-for="(header, colIdx) in realHeaderArr"
                 :class="{ 'dragging-col': header === curDraggingHeader, 'target-col': header === curMoveTarget, 'target-end': 'ENDCOL' === curMoveTarget && colIdx === realHeaderArr.length - 1, 'action-td' : columnMap[header].type === 'action' }"
                 :style="[columnMap[header].colStyle(item[header]), { width: idx === 0 && resizeWid[header] ? resizeWid[header] + 'px' : 'auto', 'min-width': idx === 0 && resizeWid[header] ? resizeWid[header] + 'px' : 'auto' }]"
                 :data-header="header")
                span(v-if="columnMap[header].type === 'data'") {{ columnMap[header].format(item[header]) }}
                input(v-if="columnMap[header].type === 'checkbox'" type="checkbox" :style="columnMap[header].colStyle(item[header])")
                div.action-cell(v-if="columnMap[header].type === 'action'"
                                @click.stop="openAction(idx)")
                  slot(name="action-box" :index="idx" :openedIdx="menuOpenedIdx" :item="item")
        div.no-data(v-if="renderList.length === 0" :style="{ 'padding-left': noDataOffsetX + 'px' }")
          span There is no matched record
</template>
<script>

import _ from 'lodash';
import Sortable from 'sortablejs';
import filterBox from './filter-box';

const TABLE_HEADER_HEIGHT = 36;
const ROW_HEIGHT = 20;
const ROW_SIZE = 60;           // number of rows to be rendered
const NUM_TRIGGER_LOAD = 5;    // number of rows below or above to trigger rerender list
// Blotter table default settings
const DEF_BLOTTER_CONFIG = {
  renderSize: ROW_SIZE,
  fixWidth: false,
  textFilterRules: [{
    type: 'cont',
    title: 'Contains',
  }, {
    type: 'nocont',
    title: 'Dose Not Contain',
  }],
};
// Column default settings
const DEF_COLUMN_OPTION = {
  title: '',           // Column header Text
  type: 'data',        // Column type: data(default), checkbox, menu, slot(custom)
  sort: true,          // Flag whether apply sort function on this column
  defaultSortType: '',     // Sort type(asc/desc) at initial render, only sort by the first column which is not set empty string
  valFilter: true,     // Flag whether apply dropdown value filter function on this column
  draggable: true,     // Flag whether this can be reorder by drag
  number: false,       // Flag whether this column is number type
  colStyle() {
    return {};
  },
  format(val) {        // Display format function
    return typeof val === 'undefined' || val === null || val === '' ? '-' : val;
  },
};

const filterFn = {
  VALUE_FILTER(inArr, field, match, allLen) {
    if (match.length === 0) return [];
    if (match.length === allLen) return inArr;
    return inArr.filter(ele => match.indexOf(this.columnMap[field].format(ele[field])) !== -1);
  },
  TEXT_FILTER(inArr, field, rules) {
    if (typeof rules === 'undefined' || rules.length === 0) return inArr;
    let reg = rules.reduce((pre, curRule) => {
      let res = '';
      let match = curRule.match;
      // Convert 1,000 to 1000
      if (this.columnMap[field].number) {
        match = match.replace(/,/g, '');
      }
      if (curRule.type === 'cont') {
        res = `(^(?=.*${match}).*)`;
      } else if (curRule.type === 'nocont') {
        res = `(^(?!.*${match}).*)`;
      }
      if (curRule.relate === 'or') {
        res += '|';
      }
      return pre + res;
    }, '');
    console.log(reg);
    reg = new RegExp(reg, 'i');
    // let regs = rules.map(rule => {
    //   let match = curRule.match;
    //   // Convert 1,000 to 1000
    //   if (this.columnMap[field].number) {
    //     match = match.replace(/,/g, '');
    //   }
    //   if (curRule.type === 'cont') {
    //     return new RegExp(`^(?=.*${match}).*`);
    //   } else if (curRule.type === 'nocont') {
    //     return new RegExp(`^(?!.*${match}).*`);
    //   } else {
    //     return undefined;
    //   }
    // })
    return inArr.filter(ele => {
      let colVol = this.columnMap[field].format(ele[field]);
      if (this.columnMap[field].number) {
        // Convert 1,000 to 1000
        colVol = colVol.replace(/,/g, '');
      }
      return reg.test(colVol);
    });
  },
};

function equalArray(a, b) {
  let res = true;
  if (!a || !b) return false;
  if (Object.prototype.toString.call(a) !== '[object Array]' || Object.prototype.toString.call(b) !== '[object Array]') return false;
  if (a.length !== b.length) return false;
  if (a === b) return true;
  a.some(ele => {
    if (b.indexOf(ele) === -1) {
      res = false;
      return true;
    }
    return false;
  });
  return res;
}

// function css(element, property) {
//   return parseFloat(getComputedStyle(element).getPropertyValue(property), 10);
// }

function insertResizeLine(targetElm, minW, height) {
  const line = document.createElement('div');
  line.style.position = 'absolute';
  line.style.top = 0;
  line.style.left = '100%';
  line.style.height = `${height}px`;
  line.style.width = '2px';
  line.style['background-color'] = '#797979';
  line.style.zIndex = '1';
  line.id = 'resize-line';
  // Delete border width
  line.setAttribute('data-min-width', minW);
  targetElm.appendChild(line);
}

export default{
  name: 'blotter-table',
  components: {
    filterBox,
  },
  directives: {
    resizeWidth: {
      inserted(el, { value }, { context }) {
        const parentElm = context.$refs.fakeHeader;
        if (typeof parentElm.dataset.initResize === 'undefined') {
          parentElm.addEventListener('mousemove', evt => {
            if (parentElm.dataset.initX) {
              const line = document.getElementById('resize-line');
              const targElm = line.parentElement;
              const targElmW = targElm.getBoundingClientRect().width;
              const lineOffset = parseInt(parentElm.dataset.initX, 10) - parseInt(evt.clientX, 10);
              const lineOffsetLeft = _.ceil(line.getBoundingClientRect().left, 2) - _.floor(targElm.getBoundingClientRect().left, 2);
              // const lineOffsetLeft = Math.abs(targElm.getBoundingClientRect().left - line.getBoundingClientRect().left);
              if (_.round(lineOffsetLeft, 2) >= line.dataset.minWidth) {
                if (targElmW - lineOffset < line.dataset.minWidth) {
                  line.style.left = `${line.dataset.minWidth}px`;
                } else {
                  line.style.left = `${targElmW - lineOffset}px`;
                }
              }
            }
          });
          parentElm.addEventListener('mousedown', evt => {
            if (evt.target.dataset.triggerResize) {
              parentElm.dataset.initX = `${evt.clientX}`;
              evt.target.dataset.triggerResize = '';
            }
          });
          parentElm.addEventListener('mouseup', () => {
            if (parentElm.dataset.initX) {
              const line = document.getElementById('resize-line');
              const targElm = line.parentElement;
              parentElm.dataset.initX = '';
              context.$emit('resize-width', targElm, targElm.dataset.header, parseFloat(getComputedStyle(line).getPropertyValue('left'), 10));
              targElm.removeChild(line);
              if (targElm.nextElementSibling.dataset.resizing) {
                // enable header click event
                setTimeout(() => {
                  targElm.nextElementSibling.dataset.resizing = '';
                }, 500);
              }
            }
          });
          parentElm.addEventListener('mouseleave', () => {
            if (parentElm.dataset.initX) {
              const line = document.getElementById('resize-line');
              const targElm = line.parentElement;
              parentElm.dataset.initX = '';
              targElm.removeChild(line);
              targElm.dataset.resizing = '';
              if (targElm.nextElementSibling.dataset.resizing) {
                targElm.nextElementSibling.dataset.resizing = '';
              }
            }
          });
          parentElm.dataset.initResize = 'Y';
        }
        el.addEventListener('mousemove', evt => {
          if (!parentElm.dataset.initX) {
            const elW = el.clientWidth;
            let limit = 3;
            if (typeof value !== 'undefined' && parseInt(value, 10) > limit && parseInt(value, 10) < (elW / 2)) {
              limit = value;
            }
            if (evt.offsetX <= limit || elW - evt.offsetX <= limit) {
              el.classList.add('cursor-resize');
              // prevent header drag
              el.classList.remove('draggable');
              if (evt.offsetX <= limit) {
                el.dataset.willResize = 'pre';
              } else {
                el.dataset.willResize = 'cur';
              }
            } else {
              el.classList.remove('cursor-resize');
              el.classList.add('draggable');
              if (el.dataset.willResize) {
                el.dataset.willResize = '';
              }
            }
          }
        });
        el.addEventListener('mouseleave', () => {
          el.classList.remove('cursor-resize');
          el.classList.add('draggable');
          if (el.dataset.willResize) {
            el.dataset.willResize = '';
          }
        });
        el.addEventListener('mousedown', () => {
          const targ = el.dataset.willResize;
          if (targ) {
            let targElm = el;
            if (targ === 'pre') {
              targElm = el.previousElementSibling;
              el.dataset.resizing = true;
            }
            targElm.dataset.resizing = true;
            insertResizeLine(targElm, targElm.dataset.minWidth, context.$refs.fakeTB.offsetHeight + context.$refs.realTB.clientHeight);
            el.dataset.triggerResize = true;
          }
        });
      },
    },
  },
  props: ['config', 'columnOpts', 'originList', 'loading'],
  data() {
    return {
      blotterData: [],
      renderIdx: 0,
      tbOffsetX: 0,
      tbOffsetY: 0,
      theaderH: TABLE_HEADER_HEIGHT,
      rowH: ROW_HEIGHT,
      widthArr: [],
      resizeWid: {},
      headerW: 0,
      fakeHeaderOrder: [],
      realHeaderOrder: [],
      noDragHeaders: [],
      sortableIns: null,
      curDraggingHeader: '',
      curMoveTarget: '',
      showDragZone: false,
      filterCriteria: {},      // Store all filter criteria which will be applied to originList to generate blotterData list
      appliedFilterCol: [],    // A stack stored all the column applied filter with applied order
      valFilterData: {},       // Store each column's value filter data
      curFilterData: {         // Data sent to child component filter-box
        showCol: '',
        dropList: [],
        selectedList: [],
        textCriteria: [],
        left: 0,
        colLeft: 0,
        type: '',
      },
      sortCriteria: {          // Store current applied sort criteria
        colHeader: '',
        type: '',
      },
      clicks: 0,
      clickTimer: null,
      menuOpenedIdx: -1,
    };
  },
  computed: {
    tbBodyH() {
      return this.blotterConfig.renderSize * this.rowH;
    },
    totalDataH() {
      return this.blotterData.length * this.rowH;
    },
    blotterConfig() {
      return Object.assign({}, DEF_BLOTTER_CONFIG, this.config);
    },
    columnMap() {
      const result = {};
      const colKeys = Object.keys(this.columnOpts);
      colKeys.forEach(col => {
        result[col] = Object.assign({}, DEF_COLUMN_OPTION, this.columnOpts[col]);
        if (this.blotterConfig.fixWidth && typeof result[col].width === 'undefined') {
          result[col].width = `${Math.floor(100 * 10 / colKeys.length) / 10}%`;
        }
      });
      return result;
    },
    renderList() {
      return this.blotterData.slice(this.renderIdx, this.renderIdx + this.blotterConfig.renderSize);
    },
    realHeaderArr() {
      return this.noDragHeaders.concat(this.realHeaderOrder);
    },
    fakeHeaderArr() {
      return this.noDragHeaders.concat(this.fakeHeaderOrder);
    },
    lastFilterCol() {
      const lastIdx = this.appliedFilterCol.length - 1;
      return lastIdx < 0 ? '' : this.appliedFilterCol[lastIdx];
    },
    noDataOffsetX() {
      return document.body.clientWidth / 2 - this.tbOffsetX;
    },
  },
  watch: {
    widthArr(newVal) {
      const fakeHeaderCols = this.$refs.fakeHeader.children;
      // clear resized column width data
      if (Object.keys(this.resizeWid).length !== 0) {
        this.resizeWid = {};
      }
      for (let i = 0, len = fakeHeaderCols.length; i < len; i++) {
        if (!fakeHeaderCols[i].dataset.minWidth || _.round(fakeHeaderCols[i].getBoundingClientRect().width, 2) !== newVal[i]) {
          fakeHeaderCols[i].style.width = newVal[i] ? `${newVal[i]}px` : 'auto';
          fakeHeaderCols[i].style['min-width'] = newVal[i] ? `${newVal[i]}px` : 'auto';
          fakeHeaderCols[i].dataset.minWidth = newVal[i] ? `${newVal[i]}` : '';
        }
        // fakeHeaderCols[i].style.width = newVal[i] ? `${newVal[i]}px` : 'auto';
        // fakeHeaderCols[i].style['min-width'] = newVal[i] ? `${newVal[i]}px` : 'auto';
        // fakeHeaderCols[i].dataset.minWidth = newVal[i] ? `${newVal[i]}` : '';
      }
    },
    blotterData: {
      handler() {
        const temp = {};
        if (this.lastFilterCol !== '') {
          temp[this.lastFilterCol] = {
            list: this.filterCriteria[this.lastFilterCol].list,
            selected: this.filterCriteria[this.lastFilterCol].match,
          };
        }
        this.valFilterData = temp;
        this.clearScroll();
        this.clearResize();
        this.$nextTick(() => {
          this.setHeaderWidth();
          this.setRowHeight();
        });
      },
      deep: true,
    },
    originList: {
      handler(newVal) {
        this.blotterData = newVal.slice(0);
        this.sortColumn();
      },
      deep: true,
    },
    sortCriteria: {
      handler() {
        this.sortColumn();
      },
      deep: true,
    },
  },
  methods: {
    setHeaderWidth() {
      const headerCols = this.$refs.realHeader.children;
      const fakeHeaderCols = this.$refs.fakeHeader.children;
      const newHeaderW = _.round(this.$refs.realHeader.getBoundingClientRect().width, 2);
      if (this.headerW !== newHeaderW) {
        this.headerW = newHeaderW;
      }
      for (let i = 0, len = headerCols.length; i < len; i++) {
        const newColW = _.round(headerCols[i].getBoundingClientRect().width, 2);
        const fakeColW = _.round(fakeHeaderCols[i].getBoundingClientRect().width, 2);
        if (this.widthArr[i] !== newColW) {
          // Can not detect changes made by directly setting array indices
          // such as this.widthArr[i] = headerCols[i].offsetWidth;
          this.$set(this.widthArr, i, newColW);
        } else if (fakeColW !== newColW) {
          this.$set(this.widthArr, i, newColW);
        }
      }
    },
    resizeWidHandler(targElm, header, newW) {
      if (targElm.dataset.minWidth <= newW) {
        const offset = newW - _.round(targElm.getBoundingClientRect().width, 2);
        if (offset !== 0) {
          this.headerW += offset;
          targElm.style.width = `${newW}px`;
          targElm.style['min-width'] = `${newW}px`;
          this.resizeWid[targElm.dataset.header] = newW;
        }
        // enable header click event
        setTimeout(() => {
          targElm.dataset.resizing = '';
        }, 500);
      }
    },
    setRowHeight() {
      if (this.theaderH !== _.ceil(this.$refs.realHeader.getBoundingClientRect().height, 2)) {
        this.theaderH = _.ceil(this.$refs.realHeader.getBoundingClientRect().height, 2);
      }
      if (this.$refs.realBody.children.length > 0) {
        const bodyRowH = this.$refs.realBody.children[0].offsetHeight;
        if (this.rowH < bodyRowH) {
          // Little adjust
          if (bodyRowH % 2 === 1) {
            this.rowH = bodyRowH + 3;
          } else {
            this.rowH = bodyRowH + 2;
          }
        }
      }
    },
    scrollHandler() {
      if (this.blotterData.length > this.blotterConfig.renderSize) {
        const scrollTop = this.$refs.realTB.scrollTop;
        const maxRenderIdx = this.blotterData.length - this.blotterConfig.renderSize;
        const viewRowNum = Math.round(this.$refs.realTB.clientHeight / this.rowH);
        const scrollRowNum = Math.round((scrollTop - this.tbOffsetY) / this.rowH);
        // Scroll down and need rerender
        // scrollRowNum + viewRowNum > this.blotterConfig.renderSize - NUM_TRIGGER_LOAD
        if (this.renderIdx < maxRenderIdx && scrollRowNum + viewRowNum > this.blotterConfig.renderSize - NUM_TRIGGER_LOAD) {
          // Guarantee the scrolled row num equal to 2 * NUM_TRIGGER_LOAD each rerender action
          const tempRenderIdx = this.renderIdx + (scrollRowNum - NUM_TRIGGER_LOAD * 2);
          if (tempRenderIdx <= maxRenderIdx) {
            this.renderIdx = tempRenderIdx;
            this.tbOffsetY = scrollTop - this.rowH * NUM_TRIGGER_LOAD * 2;
          } else {
            const newScrollRowNum = scrollRowNum - (maxRenderIdx - this.renderIdx);
            this.renderIdx = maxRenderIdx;
            this.tbOffsetY = scrollTop - this.rowH * newScrollRowNum;
          }
          this.clearResize();
          this.$nextTick(() => {
            this.setHeaderWidth();
          });
        } else if (this.renderIdx > 0 && scrollTop < this.tbOffsetY + this.rowH * NUM_TRIGGER_LOAD) {
          // Scroll up and need rerender
          // scrollTop < top + rowH * NUM_TRIGGER_LOAD
          // Guarantee the left unread row num equal to 2 * NUM_TRIGGER_LOAD each rerender action
          const tempRenderIdx = this.renderIdx + scrollRowNum - (this.blotterConfig.renderSize - viewRowNum - NUM_TRIGGER_LOAD * 2);
          if (tempRenderIdx < 0) {
            this.renderIdx = 0;
            this.tbOffsetY = 0;
          } else {
            this.tbOffsetY = this.tbOffsetY - this.rowH * (this.renderIdx - tempRenderIdx);
            this.renderIdx = tempRenderIdx;
          }
          this.clearResize();
          this.$nextTick(() => {
            this.setHeaderWidth();
          });
        }
      }
      // Horizontal scroll
      this.tbOffsetX = -this.$refs.realTB.scrollLeft;
      // Directly change left property will be high performance
      this.$refs.fakeTB.style.left = `${this.tbOffsetX}px`;
      this.curFilterData.left = this.curFilterData.colLeft + this.tbOffsetX;
    },
    uptFilterCriteria(type, field, match, list) {
      this.filterCriteria[field] = {
        type,
        match,
        list,
      };
    },
    filterColumn() {
      let tempList = this.originList.slice(0);
      // for (const field in this.filterCriteria) {
      //   if (Object.prototype.hasOwnProperty.call(this.filterCriteria, field)) {
      //     tempList = filterFn[this.filterCriteria[field].type].call(this, tempList, field, this.filterCriteria[field].match, this.valFilterData[field].list);
      //   }
      // }
      // const s = new Date();
      // const filters = Object.keys(this.filterCriteria);
      // for (let i = filters.length; i--;) {
      //   const field = filters[i];
      //   tempList = filterFn[this.filterCriteria[field].type].call(this, tempList, field, this.filterCriteria[field].match, this.valFilterData[field].list);
      // }
      // console.log(`filter time: ${new Date() - s}`);
      const s = new Date();
      Object.keys(this.filterCriteria).forEach(field => {
        // tempList = filterFn[this.filterCriteria[field].type].call(this, tempList, field, this.filterCriteria[field].match, this.valFilterData[field].list);
        tempList = filterFn[this.filterCriteria[field].type].call(this, tempList, field, this.filterCriteria[field].match, this.filterCriteria[field].list);
      });
      console.log(`filter time: ${new Date() - s}`);
      // this.blotterData = tempList;
      this.blotterData = this.sortTempData(tempList);
    },
    uptSortCriteria(header) {
      if (this.sortCriteria.colHeader === header) {
        this.sortCriteria.type = this.sortCriteria.type === 'asc' ? 'desc' : 'asc';
      } else {
        this.sortCriteria.colHeader = header;
        this.sortCriteria.type = 'asc';
      }
    },
    sortColumn() {
      if (this.sortCriteria.colHeader !== '') {
        console.log('Start sorting...');
        const s = new Date();
        const key = this.sortCriteria.colHeader;
        this.blotterData = _.orderBy(this.blotterData, ele => {
          if (this.columnMap[key].number) {
            return ele[key];
          }
          return this.columnMap[key].format(ele[key]);
        }, [this.sortCriteria.type]);
        console.log(`sorting time: ${new Date() - s}`);
      }
    },
    sortTempData(data) {
      if (typeof data !== 'undefined' && this.sortCriteria.colHeader !== '') {
        console.log('Start temp data sorting...');
        const s = new Date();
        const key = this.sortCriteria.colHeader;
        data = _.orderBy(data, ele => {
          if (this.columnMap[key].number) {
            return ele[key];
          }
          return this.columnMap[key].format(ele[key]);
        }, [this.sortCriteria.type]);
        console.log(`temp data sorting time: ${new Date() - s}`);
      }
      return data;
    },
    handleFilterData(colKey) {
      if (typeof this.valFilterData[colKey] === 'undefined') {
        const s = new Date();
        this.valFilterData[colKey] = {
          list: [],
          selected: [],
        };
        console.log('getFilterList starting...');
        if (this.columnMap[colKey].valFilter) {
          const valSet = {};
          let j = 0;
          for (let i = 0, len = this.blotterData.length; i < len; i++) {
            // If droplist item size more than 100, will not show the value filter droplist
            if (j >= 100) {
              this.valFilterData[colKey].list = [];
              this.valFilterData[colKey].selected = [];
              break;
            }
            const fmtVal = this.columnMap[colKey].format(this.blotterData[i][colKey]);
            if (valSet[fmtVal] !== 1) {
              valSet[fmtVal] = 1;
              this.valFilterData[colKey].list[j] = fmtVal;
              this.valFilterData[colKey].selected[j] = fmtVal;
              j += 1;
            }
          }
        }
        console.log(`loop time: ${new Date() - s}`);
      }
    },
    headerClickHandler(colKey, evt) {
      if (evt.currentTarget.dataset.resizing) {
        return;
      }
      this.clicks += 1;
      if (this.clicks === 1) {
        const curTarget = evt.currentTarget;
        this.clickTimer = setTimeout(() => {
          this.clicks = 0;
          this.toggleFilterBox(colKey, curTarget);
        }, 200);
      } else {
        clearTimeout(this.clickTimer);
        this.clicks = 0;
        // Toggle off sorting function: START
        this.toggleFilterBox('');
        this.uptSortCriteria(colKey);
        // Toggle off sorting function: END
      }
    },
    toggleFilterBox(colKey, curTarget) {
      const newStatus = this.curFilterData.showCol === colKey ? '' : colKey;
      if (newStatus !== '') {
        this.handleFilterData(colKey);
        this.curFilterData.dropList = this.valFilterData[colKey].list;
        this.curFilterData.selectedList = this.valFilterData[colKey].selected;
        this.curFilterData.left = parseFloat(this.$refs.fakeTB.style.left, 10) + curTarget.offsetLeft;
        this.curFilterData.colLeft = curTarget.offsetLeft;
        if (this.filterCriteria[colKey] && this.filterCriteria[colKey].type === 'TEXT_FILTER') {
          this.curFilterData.textCriteria = this.filterCriteria[colKey].match;
        } else {
          this.curFilterData.textCriteria = [];
        }
      }
      this.curFilterData.showCol = newStatus;
    },
    doFilter(type, selected) {
      const colKey = this.curFilterData.showCol;
      this.toggleFilterBox(colKey);
      if (type === 'VALUE_FILTER') {
        let reFilter = true;
        this.curFilterData.type = type;
        if (equalArray(this.valFilterData[colKey].selected, selected)) {
          reFilter = false;
        } else {
          this.valFilterData[colKey].selected = selected;
          this.curFilterData.selectedList = selected;
        }
        if (reFilter) {
          if (this.lastFilterCol === colKey && this.valFilterData[colKey].list.length === selected.length) {
            // this column will not apply value filter
            // this.filterCriteria = {};
            // this.lastFilterCol = '';
            delete this.filterCriteria[colKey];
            this.appliedFilterCol.pop();
          } else {
            this.uptFilterCriteria(type, colKey, selected, this.valFilterData[colKey].list);
            // this.lastFilterCol = colKey;
            if (this.appliedFilterCol.indexOf(colKey) > -1) {
              this.appliedFilterCol.splice(this.appliedFilterCol.indexOf(colKey), 1);
            }
            this.appliedFilterCol.push(colKey);
          }
          this.filterColumn();
        }
      } else if (selected.length > 0) {
        this.curFilterData.type = type;
        // Delete value filter data on this column
        if (this.filterCriteria[colKey] && this.filterCriteria[colKey].type === 'VALUE_FILTER') {
          this.appliedFilterCol.splice(this.appliedFilterCol.indexOf(colKey), 1);
        }
        this.uptFilterCriteria(type, colKey, selected);
        this.filterColumn();
      }
    },
    clearFilter() {
      const colKey = this.curFilterData.showCol;
      this.toggleFilterBox(colKey);
      // Delete value filter data on this column
      if (this.filterCriteria[colKey] && this.filterCriteria[colKey].type === 'VALUE_FILTER') {
        this.appliedFilterCol.splice(this.appliedFilterCol.indexOf(colKey), 1);
      }

      delete this.filterCriteria[colKey];
      this.filterColumn();
    },
    clearScroll() {
      this.renderIdx = 0;
      this.tbOffsetY = 0;
      this.$refs.realTB.scrollTop = 0;
    },
    clearResize() {
      if (Object.keys(this.resizeWid).length !== 0) {
        this.resizeWid = {};
        this.headerW = 0;
      }
    },
    openAction(idx) {
      if (this.menuOpenedIdx === idx) {
        this.menuOpenedIdx = -1;
      } else {
        this.menuOpenedIdx = idx;
      }
    },
  },
  created() {
    this.blotterData = this.originList.slice(0);
    let flag = -1;
    Object.keys(this.columnMap).forEach((key, idx) => {
      if (this.columnMap[key].draggable) {
        this.realHeaderOrder.push(key);
      } else {
        this.noDragHeaders.push(key);
      }
      if (flag === -1 && this.columnMap[key].sort && this.columnMap[key].defaultSortType !== '') {
        flag = idx;
        this.sortCriteria.colHeader = key;
        this.sortCriteria.type = this.columnMap[key].defaultSortType === 'desc' ? 'desc' : 'asc';
      }
    });
    this.fakeHeaderOrder = this.realHeaderOrder.slice(0);
  },
  mounted() {
    const self = this;
    this.$refs.realTB.addEventListener('scroll', this.scrollHandler);
    this.sortableIns = Sortable.create(this.$refs.fakeHeader, {
      filter: '.drag-zone',
      draggable: '.draggable',
      onStart(e) {
        self.curDraggingHeader = self.realHeaderOrder[e.oldIndex];
        self.showDragZone = true;
        console.log('drag function starting...');
      },
      onEnd(e) {
        if (e.newIndex !== e.oldIndex) {
          const sortHeader = self.realHeaderOrder.splice(e.oldIndex, 1)[0];
          self.realHeaderOrder.splice(e.newIndex, 0, sortHeader);
        }
        self.curDraggingHeader = '';
        self.curMoveTarget = '';
        self.showDragZone = false;
      },
      onMove(e) {
        let tempTarget;
        if (e.willInsertAfter) {
          const afterIdx = self.realHeaderArr.indexOf(e.related.dataset.header) + 1;
          if (afterIdx < self.realHeaderArr.length) {
            tempTarget = self.realHeaderArr[afterIdx];
          } else {
            tempTarget = 'ENDCOL';
          }
        } else {
          tempTarget = e.related.dataset.header;
        }
        if (self.curMoveTarget !== tempTarget) {
          self.curMoveTarget = tempTarget;
        }
      },
      onClone(e) {
        e.clone.classList.add('show-header');
      },
    });
    this.$on('resize-width', (id, header, newH) => {
      this.resizeWidHandler(id, header, newH);
    });
    // this.$on('resizing', () => {
    //   console.log('resizing');
    //   this.preventHeaderHandler = true;
    // });
    // this.$on('stop-resize', () => {
    //   console.log('stop-resize');
    //   this.preventHeaderHandler = false;
    // });
  },
};

</script>
<style scoped>

table {
  border-collapse: separate;
  border-spacing: 0;
  border: 0;
  border-right: 1px solid #d7d8d6;
  border-top: 1px solid #d7d8d6;
}

table th, table td {
  text-align: left;
  border: 0;
  border-left: 1px solid #d7d8d6;
  border-bottom: 1px solid #d7d8d6;
}

table th {
  white-space: normal;
  overflow: visible;
  background: #ededed;
}

.table tbody tr {
  border: 0;
}

.table tbody tr:hover {
  background-color: #CCE9E8;
  outline: 1px solid #99D3D1;
}

.table tbody td.action-td {
  padding: 0;
  overflow: visible;
}

.cursor-resize {
  cursor: col-resize;
}

.filter-wrapper {
  position: absolute;
  min-width: 12rem;
  max-height: calc(100% - 5rem);
  z-index: 2;
}

.height-placeholder {
  visibility: hidden;
}

.blotter-table {
  position: relative;
  width: 100%;
}

.real-table {
  width: 100%;
  height: 100%;
  overflow: auto;
}

.real-table table {
  position: relative
}

.real-table thead {
  visibility: hidden;
}

.dragging-col {
  background: rgba(160, 160, 160, .5);
}

.target-col {
  border-left: 1px solid rgb(38, 96, 191) !important;
}

.target-end {
  border-right: 1px solid rgb(38, 96, 191) !important;
}

.fake-table {
  position: absolute;
}

.fake-table th {
  position: relative;
}

.fake-table .drag-zone {
  position: absolute;
  left: 0;
  width: 100%;
  top: 28px;
  height: 300px;
  z-index: 1;
}

.fake-col {
  display: inline-block;
}

.filter-flag {
  position: absolute;
  right: -1px;
  bottom: 0;
}

.sort-flag {
  color: #555;
  font-size: 1.2rem;
  position: absolute;
  right: -1px;
  margin-top: 2px;
  /*transition: transform .8s ease-out;*/
}

.sort-flag.desc {
  transform: rotate(-180deg);
}

.sortable-ghost {
  display: none;
}

.show-header {
  display: table-cell !important;
}

.no-data {
  padding-top: 1rem;
  padding-bottom: 1rem;
  font-size: 1.6rem;
  border-bottom: 1px solid #bbb;
}

.no-data > span {
  display: inline-block;
  transform: translateX(-50%);
}

.action-cell {
  text-align: center;
  position: relative;
}

.action-cell i {
  font-size: 2.4rem;
  width: 38px;
  height: 30px;
  line-height: 30px;
}
  
</style>
